import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';
import { RclProgram } from '@rcl/language-service';

export interface CompileOptions {
  output?: string;
  format?: 'js' | 'json' | 'both';
  pretty?: boolean;
  watch?: boolean;
  configPath?: string;
}

export async function compileRCL(inputPath: string, options: CompileOptions): Promise<void> {
  // Resolve input path
  const resolvedInput = path.resolve(inputPath);
  
  if (!fs.existsSync(resolvedInput)) {
    throw new Error(`Input file not found: ${inputPath}`);
  }

  // Create RclProgram with optional config path
  const program = new RclProgram(options.configPath || path.dirname(resolvedInput));
  const config = program.getConfiguration();

  console.log(chalk.blue('üìã Configuration:'));
  console.log(chalk.gray(`  Root: ${config.rootDir || 'current directory'}`));
  console.log(chalk.gray(`  Output: ${config.outDir || 'next to source files'}`));

  // Compile the file
  console.log(chalk.blue(`üî® Compiling ${path.basename(inputPath)}...`));
  
  const result = await program.compileFile(resolvedInput);
  
  if (!result.success) {
    console.error(chalk.red('‚ùå Compilation failed:'));
    for (const diagnostic of result.diagnostics) {
      const prefix = diagnostic.severity === 'error' ? chalk.red('ERROR:') : chalk.yellow('WARNING:');
      console.error(`  ${prefix} ${diagnostic.message}`);
      if (diagnostic.file && diagnostic.line) {
        console.error(chalk.gray(`    at ${diagnostic.file}:${diagnostic.line}:${diagnostic.column || 0}`));
      }
    }
    throw new Error('Compilation failed');
  }

  // Check if we should override the output settings
  if (options.output || options.format) {
    // Manual output mode - emit to specific location
    await emitManual(result.data!, resolvedInput, options);
  } else {
    // Use RclProgram's emit
    const emitResult = await program.emit();
    
    if (!emitResult.success) {
      console.error(chalk.red('‚ùå Emit failed:'));
      for (const diagnostic of emitResult.diagnostics) {
        console.error(`  ${diagnostic.message}`);
      }
      throw new Error('Emit failed');
    }

    console.log(chalk.green('‚úÖ Successfully compiled:'));
    for (const file of emitResult.emittedFiles) {
      console.log(chalk.gray(`  ‚Üí ${path.relative(process.cwd(), file)}`));
    }
  }
}

async function emitManual(
  compiledData: any,
  inputPath: string,
  options: CompileOptions
): Promise<void> {
  const parsed = path.parse(inputPath);
  
  if (options.format === 'both' || options.format === 'json' || !options.format) {
    const jsonPath = options.output 
      ? (options.output.endsWith('.json') ? options.output : `${options.output}.json`)
      : path.join(parsed.dir, `${parsed.name}.json`);
    
    const jsonContent = JSON.stringify(compiledData, null, options.pretty ? 2 : 0);
    await fs.promises.writeFile(jsonPath, jsonContent, 'utf-8');
    console.log(chalk.green(`‚úÖ Generated: ${path.relative(process.cwd(), jsonPath)}`));
  }

  if (options.format === 'both' || options.format === 'js') {
    const jsPath = options.output 
      ? (options.output.endsWith('.js') ? options.output : `${options.output}.js`)
      : path.join(parsed.dir, `${parsed.name}.js`);
    
    const jsContent = generateJavaScript(compiledData, parsed.name);
    await fs.promises.writeFile(jsPath, jsContent, 'utf-8');
    console.log(chalk.green(`‚úÖ Generated: ${path.relative(process.cwd(), jsPath)}`));
  }
}

function generateJavaScript(data: any, baseName: string): string {
  return `// Generated by RCL CLI
// This file contains the compiled output from your RCL agent definition

import agentData from './${baseName}.json' assert { type: 'json' };

/**
 * Messages dictionary - Maps message IDs to normalized AgentMessage objects
 */
export const messages = agentData.messages;

/**
 * Flow configurations - XState machine definitions for each flow
 */
export const flows = agentData.flows;

/**
 * Agent configuration
 */
export const agent = agentData.agent;

/**
 * Get a message by ID
 */
export function getMessage(messageId) {
  return messages[messageId] || null;
}

/**
 * Get a flow configuration by ID
 */
export function getFlow(flowId) {
  return flows[flowId] || null;
}

export default {
  messages,
  flows,
  agent,
  getMessage,
  getFlow
};
`;
}