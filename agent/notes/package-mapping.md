# Package Mapping: Current vs. Proposed Architecture

This document maps the currently implemented packages in the `packages/` directory to the proposed architecture described in `ARCHITECTURE_REDESIGN.md`.

| Current Package (`packages/`) | Dependencies | Corresponding Planned Package(s) | Code & File Analysis |
| :--- | :--- | :--- | :--- |
| `@rcl/compiler` | `@rcl/core-types`, `@rcl/core-interfaces`, `@rcl/parser`, `@rcl/validation`, `@rcl/file-system` | `compiler-api`, `codegen`, `ir` | **Files:** `compiler.ts`, `pipeline/compilationPipeline.ts`, `stages/*`.<br>**Analysis:** This package orchestrates the compilation process. The `stages` (`parse`, `validate`, `transform`) confirm its role as a pipeline manager, which aligns with the `compiler-api` concept. It lacks dedicated `codegen` or `ir` directories, suggesting those concerns are mixed in. |
| `@rcl/language-service` | `@rcl/parser`, `tree-sitter` | `language-server` | **Files:** `providers/*`, `validation/*`, `workspace-index/*`, `program/RclProgram.ts`.<br>**Analysis:** This is a comprehensive language service. The `providers` (Completion, Hover, etc.) map directly to `language-server/services`. It has its own `validation` and workspace management (`RclProgram`, `WorkspaceIndex`), showing it's a much more stateful and complex component than the architecture doc implies. It's not just a thin LSP wrapper. |
| `@rcl/parser` | `@rcl/core-types`, `@rcl/core-interfaces`, `tree-sitter`, `web-tree-sitter` | `parser`, `ast` | **Files:** `rclParser.ts`, `factory/`, `ast/`, `validation/schemaValidator.ts`.<br>**Analysis:** This package is doing three jobs. It handles parsing (`rclParser.ts`), AST definitions (`ast/`), and even some schema validation (`validation/`). This violates the Single Responsibility Principle. The planned architecture correctly separates `parser` and `ast`. |
| `@rcl/validation` | `@rcl/core-types`, `@rcl/core-interfaces` | `semantic` | **Files:** `validators/semanticValidator.ts`, `validators/syntaxValidator.ts`.<br>**Analysis:** This package focuses purely on validation logic. It directly implements the validation part of the planned `semantic` package. However, the architecture document plans for a broader `semantic` package including symbol tables and type checking, which are missing here. |
| `@rcl/core-types` | (none) | `ast`, `diagnostics`, `language-api/types` | **Files:** `diagnostics.ts`, `result.ts`.<br>**Analysis:** A utility package for shared data structures. `diagnostics.ts` should belong to a dedicated `diagnostics` package. `result.ts` provides a generic Result type, a common pattern. These types should be moved to the packages that own them. |
| `@rcl/core-interfaces` | `@rcl/core-types` | (Distributed across packages) | **Files:** `compiler.ts`, `parser.ts`, `language-service.ts`, etc.<br>**Analysis:** This defines the contracts for the other modules. It's a classic example of a shared kernel, but the new architecture favors collocating interfaces with their implementations (e.g., the `Parser` interface should live in the `parser` package). |
| `@rcl/file-system` | `@rcl/core-types`, `@rcl/core-interfaces` | (Implicit Utility) | **Files:** `nodeFileSystem.ts`, `memoryFileSystem.ts`.<br>**Analysis:** A well-defined abstraction for the file system. It provides different implementations (`node`, `memory`), which is great for testing. This is a solid, practical package that supports the other high-level tools. |

### Summary of Discrepancies

1.  **Naming:** `@rcl/language-service` should probably be `@rcl/language-server`.
2.  **Granularity & Cohesion:** The functionality of the planned `ast`, `semantic`, `ir`, and `codegen` packages is currently mixed within `@rcl/compiler`, `@rcl/parser`, and `@rcl/validation`. The current implementation has lower cohesion and higher coupling than the proposed one. For example, `@rcl/parser` should not be doing validation.
3.  **Centralized Core Packages:** The current implementation leans heavily on `@rcl/core-types` and `@rcl/core-interfaces` as central, shared packages. The new design favors a more decentralized model where packages are more self-contained, defining their own types and interfaces. This reduces coupling between packages.
4.  **Language Service Complexity:** The `@rcl/language-service` is more advanced than the plan suggests, with its own program and validation logic. This isn't necessarily bad, but it deviates from the picture of a simple LSP wrapper. 